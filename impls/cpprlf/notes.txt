Run a previous steps test with a later step's interpreter:

./runtest.py tests/step2_eval.mal impls/cpprlf/step5_tco

To exclude deferrable and optional tests:

--no-deferrable --no-optional

Note that when running all the tests, the summary only covers the tests for the last step tested. Failures will stop at that step's tests. Soft fails, however, won't stop testing.

So, seeing a zero failures summary doesn't mean there weren't soft fails earlier.

In addition to DEBUG-EVAL, I've implemented DEBUG-EVAL-ENV that makes eval print the current environment if both DEBUG-EVAL and DEBUG-EVAL-ENV are truthy.

Lists and vectors are mostly the same. Differences list here as I discover them:

	- Lists, in many contexts, will be evaluated as an application;
	  Vectors won't.

There's probably a huge number of unneeded copies in this code.

The mal_func object could only hold its full ast and parsing out the parameter list and body and building the closure could be deferred until needed. But if the function gets called multiple times, it's good to have already done those things up-front. There could also be a just-in-time and memoize approach to get the best of both options.

Open docs/index.html in a web browser for some docs. But it doesn't cover some of the gotchas...like...

So far, numbers are only integers.
nil true false ; ...are all distinct types without only themselves as values.
(count nil) => 0
(let* () a b) ; ...is an error. Only one thing allowed in the body.
(fn* () a b)  ; ...is an error. Only one thing allowed in the body.

pr-str: returns string; print_readably = true
str: returns string; print_readabaly = false
prn: prints to stdout; print_readably = true
println: prints to stdout; print_readably = false

Self-hosting tests in with -Og:
42.02s user 3.09s system 98% cpu 45.726 total
...with -O3:
29.64s user 2.88s system 98% cpu 33.126 total
= about 40% faster?
