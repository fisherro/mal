;;;; A library of mal macros and functions

;;; Shortcuts for nth
(def! second (fn* (lst) (nth lst 1)))
(def! third (fn* (lst) (nth lst 2)))

;; An or macro
;; Borrowed from test_cascade.mal
(defmacro! or
  (fn* [& xs]
    (if (< (count xs) 2)
      (first xs)
      (let* [r (gensym)]
	`(let* (~r ~(first xs)) (if ~r ~r (or ~@(rest xs))))))))

;; An implementation of gensym
;;TODO: Should we make it something the reader won't read?
(def! gensym (fn* () (symbol (backtick "uuidgen"))))

;; A "for" macro based on Scheme's "do".
;;TODO: Use gensym for the "loop"?
(defmacro! for
  (fn* (var-decls stop-expr & commands)
    `(let* (loop (fn* ~(map first var-decls)
		   (if ~(first stop-expr)
		     (do ~@(rest stop-expr))
		     (do ~@commands
		       (loop ~@(map third var-decls))))))
       (loop ~@(map second var-decls)))))

;;; Folds
(def! foldl (fn* (f z lst)
		 (if (empty? lst)
		   z
		   (foldl f (f z (first lst)) (rest lst)))))

(def! foldr (fn* (f z lst)
		 (if (empty? lst)
		   z
		   (foldr f (f (first lst) z) (rest lst)))))

(def! foldl1 (fn* (f lst) (foldl f (first lst) (rest lst))))
(def! foldr1 (fn* (f lst) (foldr f (first lst) (rest lst))))

;; Infix macro; NB: No operator precedence!
(defmacro! infix
  (fn* (& args)
    (cond (= (count args) 3)
	  `(~(nth args 1) (infix ~(nth args 0)) (infix ~(nth args 2)))
	  (= (count args) 2)
	  `(~(nth args 0) (infix ~(nth args 1)))
	  (list? (first args))
	  `(infix ~@(first args))
	  "else"
	  (first args))))

;; Pipe macro
(defmacro! pipe
  (fn* (it & exprs)
    (cond (empty? exprs)
	  (throw "pipe requires at least one expression")
	  (= 1 (count exprs))
	  (first exprs)
	  (= 2 (count exprs))
	  `(let* (~it ~(first exprs)) ~(nth exprs 1))
	  "else"
	  `(let* (~it ~(first exprs)) (pipe ~it ~@(rest exprs))))))

