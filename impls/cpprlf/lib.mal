;;;; A library of mal macros and functions

;;; Shortcuts for nth
(def! second (fn* (lst) (nth lst 1)))
(def! third (fn* (lst) (nth lst 2)))

;; An or macro
;; Borrowed from test_cascade.mal
(defmacro! or
  (fn* [& xs]
    (if (< (count xs) 2)
      (first xs)
      (let* [r (gensym)]
	`(let* (~r ~(first xs)) (if ~r ~r (or ~@(rest xs))))))))

;; An implementation of gensym
;;TODO: Should we make it something the reader won't read?
(def! gensym (fn* () (symbol (backtick "uuidgen"))))

;; A "for" macro based on Scheme's "do".
;;TODO: Use gensym for the "loop"?
(defmacro! for
  (fn* (var-decls stop-expr & commands)
    `(let* (loop (fn* ~(map first var-decls)
		   (if ~(first stop-expr)
		     (do ~@(rest stop-expr))
		     (do ~@commands
		       (loop ~@(map third var-decls))))))
       (loop ~@(map second var-decls)))))

;;; Folds
;; fold is a left fold
(def! fold (fn* (f z lst)
		 (if (empty? lst)
		   z
		   (fold f (f z (first lst)) (rest lst)))))

;; foldr-simple is a straight-forward right fold
(def! foldr-simple (fn* (f z lst)
		 (if (empty? lst)
		   z
		   (f (first lst) (foldr-simple f z (rest lst))))))

;; foldr uses two folds in order to be tail recursive
(def! foldr (fn* (f z lyst)
	      (fold (fn* (a b)
		      (f b a))
		    z
		    (fold (fn* (a b)
			    (cons b a))
			  '()
			  lyst))))

;; fold1 & foldr1 don't take an initial value
(def! fold1 (fn* (f lst) (fold f (first lst) (rest lst))))
(def! foldr1 (fn* (f lst) (foldr f (first lst) (rest lst))))

;; reverse will reverse a list
(def! reverse (fn* (lyst) (fold (fn* (a b) (cons b a)) '() lyst)))

;; Infix macro; NB: No operator precedence!
(defmacro! infix
  (fn* (& args)
    (cond (= (count args) 3)
	  `(~(nth args 1) (infix ~(nth args 0)) (infix ~(nth args 2)))
	  (= (count args) 2)
	  `(~(nth args 0) (infix ~(nth args 1)))
	  (list? (first args))
	  `(infix ~@(first args))
	  "else"
	  (first args))))

;; Pipe macro
(defmacro! pipe
  (fn* (it & exprs)
    (cond (empty? exprs)
	  (throw "pipe requires at least one expression")
	  (= 1 (count exprs))
	  (first exprs)
	  (= 2 (count exprs))
	  `(let* (~it ~(first exprs)) ~(nth exprs 1))
	  "else"
	  `(let* (~it ~(first exprs)) (pipe ~it ~@(rest exprs))))))

;; Cut macro based on SRFI-26
;; This does not support the "rest slot". I haven't yet figured out a good way
;; to support it.
(defmacro! cut
  (fn* (& macro-args)
    (do
      (def! loop
	(fn* (in-args out-args n)
	    (if (empty? in-args)
	      out-args
	      (let* (in (first in-args)
			is-slot (= in '<>))
		(loop (rest in-args)
		      (concat out-args
			      (if is-slot
				`((nth func-args ~n))
				`(~in)))
		      (if is-slot (+ n 1) n))))))
      `(fn* (& func-args)
	 ~(loop macro-args '() 0)))))

;; Partial application
(def! partial
  (fn* (f & args1)
    (fn* (& args2)
      (apply f (concat args1 args2)))))

(def! partialr
  (fn* (f & args1)
    (fn* (& args2)
      (apply f (concat args2 args1)))))

