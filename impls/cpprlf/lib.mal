;;;; A library of mal macros and functions

;;; Shortcuts for nth
(def! second (fn* (lst) (nth lst 1)))
(def! third (fn* (lst) (nth lst 2)))

;; An or macro
;; Borrowed from test_cascade.mal
(defmacro! or
  (fn* [& xs]
    (if (< (count xs) 2)
      (first xs)
      (let* [r (gensym)]
	`(let* (~r ~(first xs)) (if ~r ~r (or ~@(rest xs))))))))

;; An and macro
;; Based on the or above and R5RS section 7.3.
(defmacro! and
  (fn* [& xs]
    (let* (c (count xs))
      (cond (< c 1) true
	    (= c 1) (first xs)
	    "else" `(if ~(first xs) (and ~@(rest xs)) false)))))

;; An implementation of gensym
;;TODO: Should we make it something the reader won't read?
(def! gensym (fn* () (symbol (backtick "uuidgen"))))

;; A "for" macro based on Scheme's "do".
;;TODO: Use gensym for the "loop"?
(defmacro! for
  (fn* (var-decls stop-expr & commands)
    `(let* (loop (fn* ~(map first var-decls)
		   (if ~(first stop-expr)
		     (do ~@(rest stop-expr))
		     (do ~@commands
		       (loop ~@(map third var-decls))))))
       (loop ~@(map second var-decls)))))

;;; Folds
;; fold is a left fold
;; Based on the Wikipedia article.
(def! fold (fn* (f z lst)
		 (if (empty? lst)
		   z
		   (fold f (f z (first lst)) (rest lst)))))

;; foldr-simple is a straight-forward right fold
;; Based on the Wikipedia article.
(def! foldr-simple (fn* (f z lst)
		 (if (empty? lst)
		   z
		   (f (first lst) (foldr-simple f z (rest lst))))))

;; foldr uses two folds in order to be tail recursive
;; As suggested by the Wikipedia article.
(def! foldr (fn* (f z lyst)
	      (fold (fn* (a b)
		      (f b a))
		    z
		    (fold (fn* (a b)
			    (cons b a))
			  '()
			  lyst))))

;; fold1 & foldr1 don't take an initial value
;; Based on the Wikipedia article.
(def! fold1 (fn* (f lst) (fold f (first lst) (rest lst))))
(def! foldr1 (fn* (f lst) (foldr f (first lst) (rest lst))))

;; reverse will reverse a list
(def! reverse (fn* (lyst) (fold (fn* (a b) (cons b a)) '() lyst)))

;;; Unfolds
;; Unfold-simple is unfold from SRFI-1. It is NOT tail recursive.
;; The optional tail parameter is not supported.
(def! unfold-simple
  (fn* (p f g seed)
    (if (p seed) '()
      (cons (f seed)
	    (unfold-simple p f g (g seed))))))

;; Unfold is like unfold from SRFI-1 but (internally) transformed to
;; CPS so that it is tail recursive.
;; The optional tail parameter is not supported.
(def! unfold
  (fn* (p f g seed)
    (do
      (def! pk (fn* (x k) (k (p x))))
      (def! fk (fn* (x k) (k (f x))))
      (def! gk (fn* (x k) (k (g x))))
      (def! cons-k (fn* (x y k) (k (cons x y))))
      (def! helper-k
	(fn* (seed k)
	  (pk seed (fn* (bool)
		     (if bool (k '())
		       (fk seed (fn* (f-seed)
				  (gk seed (fn* (g-seed)
					     (helper-k g-seed (fn* (helper-result)
								(cons-k f-seed helper-result k))))))))))))
      (helper-k seed (fn* (x) x)))))

;; unfoldr is SRFI-1's unfold-right.
;; The optional tail parameter is not supported.
(def! unfoldr
  (fn* (p f g seed)
    (do
      (def! loop
	(fn* (s lyst)
	  (if (p s) lyst (loop (g s) (cons (f s) lyst)))))
      (loop seed '()))))

;; Infix macro; NB: No operator precedence!
(defmacro! infix
  (fn* (& args)
    (cond (= (count args) 3)
	  `(~(nth args 1) (infix ~(nth args 0)) (infix ~(nth args 2)))
	  (= (count args) 2)
	  `(~(nth args 0) (infix ~(nth args 1)))
	  (list? (first args))
	  `(infix ~@(first args))
	  "else"
	  (first args))))

;; Pipe macro
(defmacro! pipe
  (fn* (it & exprs)
    (cond (empty? exprs)
	  (throw "pipe requires at least one expression")
	  (= 1 (count exprs))
	  (first exprs)
	  (= 2 (count exprs))
	  `(let* (~it ~(first exprs)) ~(nth exprs 1))
	  "else"
	  `(let* (~it ~(first exprs)) (pipe ~it ~@(rest exprs))))))

;; Cut macro based on SRFI-26
;; This does not support the "rest slot". I haven't yet figured out a good way
;; to support it.
(defmacro! cut
  (fn* (& macro-args)
    (do
      (def! loop
	(fn* (in-args out-args n)
	    (if (empty? in-args)
	      out-args
	      (let* (in (first in-args)
			is-slot (= in '<>))
		(loop (rest in-args)
		      (concat out-args
			      (if is-slot
				`((nth func-args ~n))
				`(~in)))
		      (if is-slot (+ n 1) n))))))
      `(fn* (& func-args)
	 ~(loop macro-args '() 0)))))

;; Partial application
(def! partial
  (fn* (f & args1)
    (fn* (& args2)
      (apply f (concat args1 args2)))))

(def! partialr
  (fn* (f & args1)
    (fn* (& args2)
      (apply f (concat args2 args1)))))

